class CirculerQ{
    int [] arr;
    int front , rear , size, capacity;

    CirculerQ(int k){
        capacity = k;
        arr = new int[k];
        front = 0;
        rear = -1;
        size = 0;
    } 

    public boolean isfull(){
        if(size == capacity)return true;
        return false;
    }

    public boolean isempty(){
        if(size == 0)return true;
        return false;
    }

    public void enqueue(int val){
        if(isfull()){
            System.out.println("queue is full");
            return;
        }
        rear = (rear+1)%capacity;
        size++;
        arr[rear] = val;
    }

    public void dequeue(){
        if(isempty()){
             System.out.println("there no element to dequeue");
             return;
        }
        front = (front+1) % capacity;
        size--;
    }

    public void display(){
        if(isempty()){
            System.out.println("queue is empty");
            return;
        }
        int i = front ;
        int count = 0;
        while(size > count){
            System.out.print(arr[i]+",");
            i = (i+1)%capacity;
            count++;
        }
        System.out.println();

    }

    public static void main(String[] args) {
        CirculerQ q = new CirculerQ(5);
        q.display();
        q.enqueue(10);
        q.display();
        q.dequeue();
        q.dequeue();
        q.display();
        q.enqueue(10);
        q.enqueue(20);
        q.enqueue(30);
        q.display();
        q.dequeue();
        q.display();
    }
}

    





class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] dq = new int[nums.length];
        int[] result = new int[nums.length - k +1];
        int front = 0, rear = -1;
        int c = -1;

        for(int i=0;i<k;i++){
            while(front <= rear && nums[i] >= nums[dq[rear]] )rear--;
            dq[++rear] = i;
        }

        for(int i=k ; i < nums.length ; i++){
            result[++c] = nums[dq[front]];
            while(front <= rear && dq[front] <= i-k)front++;
            while(front <= rear && nums[i] >= nums[dq[rear]] )rear--;
            dq[++rear] = i;
        }
        result[++c] = nums[dq[front]];
        return result;
    }
}









class QueueUsingStack {

    int[] s1, s2;
    int t1, t2, n;

    QueueUsingStack(int size) {
        n = size;
        s1 = new int[size];
        s2 = new int[size];
        t1 = -1;
        t2 = -1;
    }

    public boolean isFull() {
        return (t1 == n - 1);
    }

    public boolean isEmpty() {
        return (t1 == -1 && t2 == -1);
    }

    // Move from s1 to s2 ONLY when s2 is empty
    private void shiftStacks() {
        if (t2 == -1) {
            while (t1 != -1) {
                s2[++t2] = s1[t1--];
            }
        }
    }

    public void enqueue(int val) {
        if (isFull()) {
            System.out.println("Queue is full");
            return;
        }
        s1[++t1] = val;
    }

    public void dequeue() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        shiftStacks();
        t2--;  // pop from s2
    }

    public void front() {
        if (isEmpty()) {
            System.out.println("Queue is empty");
            return;
        }
        shiftStacks();
        System.out.println("Front: " + s2[t2]);
    }

    public static void main(String[] args) {
        QueueUsingStack q = new QueueUsingStack(5);
        q.enqueue(1);
        q.enqueue(3);
        q.dequeue();
        q.front();
    }
}





class RoundRobin { 
    static void schedule(String[] jobs, int[] burst, int q) { 
        int n = jobs.length; 
        int[] rem = new int[n]; 
        int[] finish = new int[n]; 
        int time = 0, done = 0; 
        for (int i = 0; i < n; i++) rem[i] = burst[i]; 
        while (done < n) { 
            for (int i = 0; i < n; i++) { 
                if (rem[i] > 0) { 
                    if (rem[i] > q) { 
                        time += q; 
                        rem[i] -= q; 
                    } else { 
                        time += rem[i]; 
                        rem[i] = 0; 
                        finish[i] = time; 
                        done++; 
                        System.out.print(jobs[i] + " "); 
                    } 
                } 
            } 
        } 
    } 
 
    public static void main(String[] args) { 
        String[] jobs = {"J1", "J2", "J3"}; 
        int[] burst = {5, 3, 7}; 
        int q = 2; 
        schedule(jobs, burst, q);






class PrinterQueue { 
    static int findOrder(int[] pri, int target) { 
        int n = pri.length; 
        int[] index = new int[n]; 
        for (int i = 0; i < n; i++) index[i] = i; 
        int count = 0; 
        while (true) { 
            int max = pri[0]; 
            for (int i = 1; i < n; i++) if (pri[i] > max) max = pri[i]; 
            if (pri[0] == max) { 
                count++; 
                if (index[0] == target) return count; 
                for (int i = 0; i < n - 1; i++) { 
                    pri[i] = pri[i + 1]; 
                    index[i] = index[i + 1]; 
                } 
                n--; 
            } else { 
                int tempP = pri[0], tempI = index[0]; 
                for (int i = 0; i < n - 1; i++) { 
                    pri[i] = pri[i + 1]; 
                    index[i] = index[i + 1]; 
                } 
                pri[n - 1] = tempP; 
                index[n - 1] = tempI; 
            } 
        } 
    } 
 
    public static void main(String[] args) { 
        int[] priorities = {1, 1, 9, 1, 1, 1}; 
        int target = 0; 
        System.out.println(findOrder(priorities, target)); 
    } 
} 




